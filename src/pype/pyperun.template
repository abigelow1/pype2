#!%%PYTHONEXE%%
# -*- Mode: Python; tab-width: 4; py-indent-offset: 4; -*-

"""
Author
-------------------
James A. Mazer (mazer@socrates.berkeley.edu)

Description
-------------------

Functions
-------------------

Classes
-------------------

Revision History
-------------------
Wed Dec 26 15:58:28 2001 mazer
  Front end loader for "pype".  This is like the old pype shell
  script, but it's pure python (execept that it needs root access
  via pypeboot...

  Usage:
		pyperun [task]     -> run with gui & framebuffer
        pyperun -s [args]  -> interactive shell (aka pypenv)

Mon Sep 18 10:00:05 2006 mazer
  Notes about variables

  PYPEDIR       This is the install directory for pype
  PYPERC        User's configuration directory. This defaults to
                ~/.pyperc, unless overridden with an environment
                variable
  PYPETASKPATH  colon-delimited search path
  SUBJECT       subject id (for subject-specific config files)
"""

debug = 0

import sys, posixpath, os, glob, string


original_argv = sys.argv[:]
av = []
for a in sys.argv:
    if a == '--debug':
        debug = 1
    elif a[:2] == 's=':
        os.environ['SUBJECT'] = a[2:]
    else:
        av.append(a)
sys.argv = av

if debug:
    sys.stderr.write('orig argv: %s\n' % original_argv)
    sys.stderr.write('     argv: %s\n' % sys.argv)

def addpath(d, end=None):
    """
    Add directory to the HEAD (or TAIL) of the python search path.
    """
    if end:
        sys.path = sys.path + [d]
    else:
        sys.path = [d] + sys.path + [d]

def run_python_script(fullname, debug):
    """
    Run module as script -- script name SHOULD have .py extension!!
    """
    import imp

    name = posixpath.basename(fullname)

    # strip the .py off, if it's there..
    if name[(len(name)-3):] == '.py':
        name = name[:-3]

    p = [string.join(fullname.split('/')[0:-1],'/')]
	for path, fname in ((None, name), (None,name+'.py'),
                        (p, name), (p,name+'.py')):
        try:
            if path is None:
                fp, pathname, description = imp.find_module(fname)
            else:
                fp, pathname, description = imp.find_module(fname, path)
        except ImportError:
            continue

		sys.argv[0] = pathname
        try:
            if debug:
                sys.stderr.write("[script '%s' from '%s']\n" % \
                                 (fullname, pathname))
            mod = imp.load_module('__main__', fp, pathname, description)
        finally:
            fp.close()
        return 1
    return 0
	
if not os.environ.has_key('HOME'):
	sys.stderr.write('%s: please set $HOME and restart\n' % sys.argv[0])
	sys.exit(1)

#
# NOTE: \%\%PYPEDIR\%\% gets expanded by the Buildfile system!
#
if not os.environ.has_key('PYPEDIR'):
    os.environ['PYPEDIR'] = "%%PYPEDIR%%"
    sys.stderr.write('Warning: $PYPEDIR unset, using "%s".\n' % \
                     os.environ['PYPEDIR'])

# rest of this section sets up the python search path to find
# all the pype modules and tasks

# setup the path as follows:
#  <current directory>
#  <$PYPERC/Tasks>
#  <$PYPERC/Modules>
#  <$PYPEDIR/Tasks>
#  <$PYPEDIR/lib> (this used to be $PYPEDIR/Modules, but changed 14-jan-04)
#  ...everything in original $PYTHONPATH...
#  where, $PYPERC defaults to $HOME/.pyperc if it's not specified

pd = os.environ['PYPEDIR']+'/'
for d in ['.', pd+'Tasks', pd+'lib', pd+'Modules']:
    addpath(d)

# PREFIX specific user-defined paths that can contain. PYPEPATH should
# be a standard colon-delimted set of paths to search
if os.environ.has_key('PYPETASKPATH'):
    for d in string.split(os.environ['PYPETASKPATH'], ':')[::-1]:
        addpath(d)

# Fri Dec 13 17:12:22 2002 mazer
#  -- add $PYPEDIR/lib onto LD_LIBRARY_PATH
#     to make sure DACQ modules can pickup the
#     eyelink shared library file..

if os.environ.has_key('LD_LIBRARY_PATH'):
    os.environ['LD_LIBRARY_PATH'] = os.environ['PYPEDIR'] + '/lib:' + \
                                    os.environ['LD_LIBRARY_PATH']

# now that $PYPEDIR is partially setup, pype and pype modules
# should be importable...

# 1st check to see that Numeric and pygame are properly installed:
from info import libinfo
info = libinfo()
for k in ('numeric', 'pygame'):
    if info[k] is None:
        sys.stderr.write("Error: %s not installed locally.\n" % k)
        sys.exit(1)

try:
	import pype
except ImportError:
    sys.stderr.write("""Error on 'import pype'. Check $PYPEDIR\n""")
	sys.exit(1)

# add the ~/.pyperc directories to the python search path
for i in ['Tasks', 'Modules']:
    addpath(pype.pyperc(i))

for d in glob.glob(pype.pyperc('Tasks/*')):
    if os.path.isdir(d):
        addpath(d)

if debug:
    import importer
    sys.stderr.write('Search Path:\n')
    for d in sys.path:
        if len(d) > 0:
            sys.stderr.write('  %s\n' % d)

if len(sys.argv) > 1 and sys.argv[1] == '-s':
    # *** Invoked as pypenv ***
    # 
    # pypenv is really a shell script that does:
    #   exec pyperun -s $*
    # So, the -s argument indicates run as a standard python
    # interpreter (with the path set to include pype stuff).
    # Otherwise, you get the full blow pype GUI.
    if len(sys.argv) == 2:
        # This means there's not command line arguments, so we want to
        # just drop into an interactive shell. First we see if the
        # IPython packages is installed for a fancier shell..
        # interactive mode, drop into an interactive shell
        try:
            from IPython.Shell import IPShellEmbed
            ipshell = IPShellEmbed([])
            ipshell()
        except ImportError:
            # IPython's not installed, fall back to standard python
            # interactive shell
            import code
            sys.stdout.write("<<<<pypenv: interactive python shell>>>>\n")
            code.interact()
    else:
        # Last possibility for pypenv is that we've been invoked with
        # command line options. Command line options are assumed to
        # be a module to load and run, just like a standard python
        # program.
        #
        # Tod do that, we trim .../pyperun from the head of sys.argv
        # and let run_python_script() replace the -s with the module
        # name and then go ahead and load+run the module.
        sys.argv = sys.argv[2:]
        if run_python_script(sys.argv[0], debug) == 0:
            sys.stderr.write("Can't find module '%s'\n" % sys.argv[0])
            sys.exit(1)
else:
    # *** Invoked as pype ***
    #
    # This means we want to startup in full GUI mode, but
    # we're 
    # parse command line

    # make sure subject dir exists, if it doesn't go ahead and make it
    if not posixpath.exists(pype.subjectrc()):
        sys.stderr.write('Subject dir does not exist.\n')
        sys.stderr.write('Building: %s\n' % pype.subjectrc())
        try:
            os.mkdir(pype.subjectrc())
            os.chown(pype.subjectrc(), os.getuid(), os.getgid())
        except:
            sys.exit(0)
    
    av = []
    psych = 0
    for n in range(1, len(sys.argv)):
        if sys.argv[n] == '-p':
            # psychophysics mode (withdraw framebuffer)
            psych = 1
        else:
            av.append(sys.argv[n])

    # startup pype with gui
	from pype import *

	try:
		app = PypeApp(psych=psych)
	except FatalPypeError:
		sys.exit(1)

    if len(av) > 0:
        taskname = posixpath.splitext(av[0])[0]
		try:
			app.newloadtask(taskname)
		except ImportError:
			sys.stderr.write("%s: can't load task '%s'\n" % \
							 (sys.argv[0], taskname))
			sys.exit(1)

    while not app.terminate:
        app.idlefn(toplevel=1)
	app.close()
